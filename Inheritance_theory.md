Inheritance Theory

Как по терминологии Java называются базовый класс и наследуемый класс?

**Ответ.** Согласно терминологии Java, базовый класс называется суперкласс (базовый, родительский), а наследуемый класс - подкласс (производный, дочерний).

**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html

Какой класс является родительским для всех классов?

**Ответ:** ObjectКласс, в java.langпакете, сидит на вершине дерева иерархии классов. Каждый класс является прямым или косвенным потомком Objectкласса

**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html

Какой класс является родительским для всех перечислений?

**Ответ.** Родительским для всех перечислений является класс java.lang.Enum

**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html

Какой интерфейс является родительским для всех интерфейсов?

**Ответ.** Интерфейсы не имеют общего предка

**Источник.** https://docs.oracle.com/javase/8/docs/api/java/lang/package-tree.html

Сформулируйте критерий отношения наследования между двумя сущности физического мира.
Другими словами, какому условию должны удовлетворять две сущности физического мира, чтобы соответствующие им классы были связаны отношением наследования?

**Ответ.** Сущность 1 вступает в отношение наследования к сущности 2 в том случае, если сущность 1 является частным случаем сущности 2 (выполняется отношение “is-a”).

**Источник.** http://skipy.ru/philosophy/inheritance.html

Есть ли отношение наследования между сущностями:
а) квадрат и прямоугольник;
б) сосна и доска;
в) книга и страница?
Поясните ответ.

**Ответ:**
a.	Квадраты не являются прямоугольниками. У них много общего, безусловно, но в конечном счете ограничения квадрата не годятся для прямоугольников (то же самое верно, кстати, для эллипсов и окружностей.Эта засада известна под названием «принцип замещения Лисков» (Liskov Substitution Principle): любой тип, который наследует от другого, должен быть полностью замещаемым для этого предка. Или, если использовать слова, которыми Лисков сформулировала свой принцип:«Пусть q(x) является свойством, верным относительно объектов x некоторого типа T. Тогда q(y) также должно быть верным для объектов y типа S, где S является подтипом типа T».
b.	Не является наследованием, так как здесь отношение композиции.
c.	Не является наследованием?

В jdk класс RuntimeException является подклассом Exception.
Есть ли нарушение критерия наследования?
Поясните ответ.

**Ответ.** Есть. В Java все исключения делятся на два типа: контролируемые исключения (checked) и неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) и исключения времени выполнения (RuntimeExceptions, потомок класса Exception). Контролируемые исключения представляют собой ошибки, которые можно и нужно обрабатывать в программе, к этому типу относятся все потомки класса Exception (но не RuntimeException).

**Источник.** http://javastudy.ru/interview/exceptions/

В чем смысл конструкции  super?
Перечислите случаи, когда используется конструкция  super.
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими
возможностями. Если можно, то каким образом?

**Ответ.** Ключевое слово super применяется для обращения к конструктору суперкласса и для доступа к полю или методу суперкласса. Например:
super(список_параметров); /* обращение к конструктору суперкласса
с передачей параметров или без нее*/
super.id = 35; /* обращение к атрибуту суперкласса */
super.getId(); // вызов метода суперкласса
1. 	Явный вызов конструктора суперкласса из подкласса (только в качестве первой строки кода и только один раз). Можно заменить с помощью дублирования кода конструктора суперкласса, если позволит инкапсуляция. В любом случае это антипаттерн.
2. 	Доступ из подкласса к переопределённому методу или перекрытому полю суперкласса (super.overrideMethod()). Причем, если в суперклассе этот метод не определен, то будет осуществляться поиск по цепочке наследования до тех пор, пока он не будет найден. Во всех случаях с использованием super можно обратиться только к ближайшему суперклассу, т. е. «перескочить» через суперкласс, чтобы обратиться к его суперклассу, невозможно. В случае переопределенных методов полноценно заменить конструкцию super нельзя. Сокрытие же полей не рекомендуется.
3. 	Wildcard (метасимвольные аргументы, маски) в дженериках: List <? super Integer>. Заменить нельзя.
      
**Источники.** И.Н. Блинов, В.С. Романчик. Java Методы программирования 2013, с.102
      https://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html

Можно ли одновременно использовать this() и super() в конструкторе?
Поясните ответ.

**Ответ.** Нет. Инструкция this(), как и инструкция super(), должна быть единственной в вызывающем конструкторе и быть первой по счету выполняемой операцией, т. е. обращение к конструктору суперкласса (собственного класса) становится невозможным.

**Источник.** И. Блинов. Java. Методы программирования. с. 103.
https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8.7

Дан код.
class SomeClass() {
...
public SomeClass() {
doSmth();
}
protected void doSmth() {
...
}
}
Это потенциальный антипаттерн. Почему?

**Ответ:** Конструкторы класса не должны вызывать переопределяемые методы, непосредственно или опосредованно. Нарушение этого правила может привести к аварийному завершению программы. Конструктор суперкласса выполняется прежде конструктора подкласса, а потому переопределяющий метод в подклассе будет вызываться перед запуском конструктора этого подкласса. И если переопределенный метод зависит от инициализации, которую осуществляет конструктор подкласса, то этот метод будет работать совсем не так, как ожидалось.

**Источник.** Джошуа Блох – Джава Эффективное программирование Статья 15

Если класс реализует некоторый интерфейс, то необходимо ли в нем определить все методы, объявленные в интерфейсе?

**Ответ.** Не обязательно. Если класс реализует интерфейс, но полностью не реализует его методы, то класс должен быть объявлен абстрактным. Иначе - синтаксическая ошибка.

**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html

Для каких целей необходим интерфейс, в котором не объявлено ни одного метода?

**Ответ.** Интерфейс, который не содержит ни одного метода, используется в следующих случаях:
1.В качестве маркера для класса (прим. Serializable, Cloneable). Такие интерфейсы не содержат методов. Если класс реализует один из таких интерфейсов это означает, что он может реализовать определенный функционал (прим. сериализовать или клонировать свои объекты).
2. В Java можно объявлять объектные ссылки, которые имеют тип интерфейса, а не класса. Такие переменные могут ссылаться на объекты любых классов, реализующих данный интерфейс. Это может быть использовано для хранения в коллекциях и массивах объектов, имеющих различную иерархию наследования.
3. Для хранения констант. Такие интерфейсы используются для определения общего свойства, либо для определения принадлежности классов, реализующих данный интерфейс, к общей группе.
   
**Источник.** И. Блинов. Java. Методы программирования. С. 150.

Можно ли переопределить метод в том же самом классе? Можно ли его перегрузить в этом классе?

**Ответ.** Переопределить метод (одно и то же имя и сигнатура) в том же самом классе нельзя, потому что компилятор не будет знать к какому из двух методов вы обращаетесь. Перегрузить метод можно сколько угодно раз, потому как в перегруженных методах различное количество и/или тип параметров.

**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html

Можно ли переопределить метод в подклассе? Можно ли его перегрузить в подклассе?
Можно ли переопределить метод в том же самом классе? Можно ли его перегрузить в этом классе?

**Ответ.** Переопределить метод (одно и то же имя и сигнатура) в том же самом классе нельзя, потому что компилятор не будет знать к какому из двух методов вы обращаетесь. Перегрузить метод можно сколько угодно раз, потому как в перегруженных методах различное количество и/или тип параметров.

**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html

Можно ли переопределить статический метод? Поясните ответ.

**Ответ.** Нет. Для статических методов принципы «позднего связывания» не используются. Динамический полиморфизм к статическим методам класса неприменим, так как обращение к статическому атрибуту или методу осуществляется по типу ссылки, а не по типу объекта, через который производится обращение. Версия вызываемого статического метода всегда определяется на этапе компиляции. При использовании ссылки для доступа к статическому члену компилятор при выборе метода учитывает тип ссылки, а не тип объекта, ей присвоенного.

**Источник.** И. Блинов. Java. Методы программирования. с. 107.

Как запретить переопределение метода в подклассе? Назовите 2 способа.

**Ответ.**
1. Использовать ключевое слово final в объявлении метода, чтобы указать, что метод не может быть переопределен подклассами. Разработчик, объявляющий метод как final, считает, что его версия метода окончательна и не может иметь другой реализации.
2. Использовать модификатор доступа private, что делает невозможным переопределение соответствующего метода в подклассе.
   
**Источники.** https://docs.oracle.com/javase/tutorial/java/IandI/final.html
   https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html

С помощью какого механизма реализуется полиморфизм в Java?

**Ответ.** С помощью механизма «позднего связывания».

**Источник.** И. Блинов. Java. Методы программирования. с. 97.

Верно ли утверждение, что если есть ссылка на объект подкласса, то тем самым есть ссылка на объект суперкласса? Если да, то как ее получить?


SmallEntity и BigEntity - это подклассы Entity.
Можно ли отрефакторить данный код? Если да, то выполните.
class EntityFactory {
public static Entity getEntity(int num) {
switch(num) {
case 2: return new Entity();
case 3: return new SmallEntity();
case 4: return new BigEntity();
default: throw new IllegalArgumentException();
}
}
}

**Ответ:** Можно отрефакторить в шаблон Factory Method следующим образомЖ
public enum EntityFactory {
ENTITY{
@Override
public Entity getEntity(){
return new Entity();
}
},
SMALL ENTITY {
@Override
public Entity getEntity() {
return new SmallEtity();
}
},
BIG_ENTITY {
@Override
public Entity getEntity(){
return new BigEntity();
}
};

	public abstract Entity getEntity();
}


Можно ли отрефакторить данный код? Если да, то выполните.
class Entity {
...
private String action;
public void doSmth() {
switch(action) {
case "sing-solo": singSolo(); break;
case "sing-duet": singDuet(); break;
case "dance": dance();
}
}
private void singSolo() {
...
}
private void singDuet() {
...
}
private void dance() {
...
}
}

**Ответ.** Можно отрефакторить внутренний алгоритм в операторе switch:
class Entity {
...
private String action;
public void doSmth() {
switch(action) {
case "sing-solo": singSolo(); break;
case "sing-duet": singDuet(); break;
case "dance": dance(); break;
default: System.out.println("Not implemented action: " + action);
}
}
private void singSolo() {
...
}
private void singDuet() {
...
}
private void dance() {
...
}
}

Пусть А - абстрактный класс, а - ссылка на А, класс В расширяет класс А. Можно ли создать объект класса В по ссылке а?
Пусть I - интерфейс, i - ссылка на I, b - ссылка на B, класс В реализует интерфейс I. Можно ли создать объект класса В по ссылке i? Можно ли выполнить операции:
1. b = i; ?
2. i = b; ?

**Ответ.** Да, можно создать.
   A a; // ссылка на класс А
   a = new B(); // Можно создать объект класса B по ссылке а
   
**Источник.** И. Блинов. Java. Методы программирования. с. 108.

В чем заключается отличие сравнения принадлежности к классу через операцию instanceof и метод getClass()?

Можно ли создать:
1. ссылку на объект абстрактного класса?
2. объект абстрактного класса?
3. ссылку на интерфейс?
4. объект типа интерфейс?
   
**Ответ.**
1. ссылку на объект абстрактного класса создать можно.
   public abstract class C {}
   public class Runner {
   public static void main(String[] args) {
   C c;
   }
   }
2. объект абстрактного класса создать нельзя.
3. ссылку на интерфейс создать можно.
   public interface I {}
   public class Runner {
   public static void main(String[] args) {
   I i ;
   }
   }
4. объект типа интерфейс создать нельзя.

**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html

Может ли класс:
1. реализовывать два интерфейса?
2. расширять два класса?
3. расширять два интерфейса?
4. расширять один класс и реализовывать один интерфейс?
5. расширять сам себя?
   
**Ответ.**
1. Класс может реализовывать два и более интерфейсов.
   public interface I1 {}
   public interface I2 {}
   public class B implements I1, I2 {}
2. Множественное наследование в Java запрещено.
3. Класс не может расширять интерфейсы.
4. Класс может расширять один класс и реализовывать один и более интерфейсов
   public interface I {}
   public class A {}
   public class B extends A implements I {}
5. расширять сам себя класс не может.
   
**Источник.**  	https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html
   
Для каких целей используется расширение интерфейса?

**Ответ.** Если необходимо добавить к ранее созданному интерфейсу новый метод так, чтобы  программы, написанные ранее с осуществлением первоначальной версии интерфейса, не утратили своей работоспособности, то одним из способов сделать это является создание нового интерфейса, который будет расширять (extends) прежний. При этом у пользователей (программистов) появится выбор: использовать старую версию интерфейса или обновить свою программу и использовать новую версию.

**Источник.** http://docs.oracle.com/javase/tutorial/java/IandI/nogrow.html

Могут ли в интерфейсе быть поля?

**Ответ.** Да, но только инициализированные константы. (public static final)

**Источник.** И. Блинов. Java. Промышленное программирование. с. 152.

Можно ли в интерфейсе
1. объявить метод с пакетным уровнем доступа?
2. объявить конструктор?
3. определить конструктор?
   
**Ответ.**
1) Нельзя, т.к. все объявленные в интерфейсе методы автоматически трактуются как
   public и abstract, даже если они так не объявлены.
2) Нельзя, т.к. тело интерфейса может содержать лишь: абстрактные методы (abstract) и объявления констант, а начиная с Java 8 - еще и методы по умолчанию (default), а также статические методы (static). Кроме того, конструктор — особого вида метод, который по имени автоматически вызывается при создании экземпляра класса с помощью оператора new. Но интерфейс лишь определяет поведение объектов, его реализующих, поэтому экземпляры интерфейсов не создают.
3) Нельзя, см. 2
   
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/interfaceDef.html
          https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.4

Можно ли интерфейс объявить финальным? Поясните ответ.

**Ответ.** Нет, т.к. интерфейсы должны быть реализованы классами. Интерфейс представляет собой поведение, а не реализацию, поэтому для него нет никакого смысла быть финальным.

**Источник:** https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html

Можно ли в интерфейсе объявить статический метод? Поясните ответ.

**Ответ.** В интерфейсе все методы неявно объявляются как abstract. Статические методы не могут быть абстрактными. Т. к. статические методы не могут быть переопределены (из-за привязки к типу класса, а не к объекту класса), то они должны сразу иметь реализацию.
Начиная с JDK8, интерфейсы могут иметь методы с реализацией, обозначаемые default, а также статические методы. Таким образом становится возможным применение статических методов с реализацией в интерфейсе.

**Источник.** https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.4

Можно ли вызвать статический метод через объектную ссылку? Поясните ответ.

**Ответ.** Можно, но вызов статических методов через объект считается нетипичным и нарушающим смысл статического определения.

**Источник.** И. Блинов. Java. Промышленное программирование. с. 107-108.

Можно ли создать экземпляр класса, у которого есть абстрактный метод? Если да, то зачем?

**Ответ.** Если класс имеет хотя бы один абстрактный метод, то его также следует объявить абстрактным. Создавать экземпляр абстрактного класса нельзя, можно объявить только ссылку на абстрактный класс, но инициализировать ее необходимо объектом какого-то подкласса, реализующим все абстрактные методы.

**Источник.** И. Блинов. Java. Промышленное программирование. с. 108.

Должен ли иметь абстрактный класс хотя бы один абстрактный метод? Если нет, то зачем объявлять такой класс абстрактным?
Ответ. К абстрактным классам нет требования иметь хотя бы один абстрактный метод.
Объявление класса абстрактным запрещает создавать экземпляры такого класса.
Он может понадобиться, например, для выделения общих “состояний” (полей) у нескольких подклассов.
Источник. https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html

Что означает ключевое слово final в следующих конструкциях?
1.
public final class SomeClass() { }
2.
public class SomeClass() {
public final void doSmth();
}

**Ответ:**
1. Если в объявлении класса стоит модификатор final, это значит, что от данного класса нельзя наследоваться.
2. Если для метода указан модификатор final — этот метод нельзя переопределить.
   
**Источник.** https://javarush.ru/groups/posts/1946-neizmennoe-v-java-final-konstantih-i-immutable

Можно ли объявить метод одновременно финальным и абстрактным? Поясните ответ.

**Ответ.** Нет, так как эти модификаторы по отношению к методам в плане наследования противоречат друг другу. Абстрактный метод наследуется, а финальный — нет.
Так же, это противоположные по сути понятия из-за того, что финальный метод запрещает своё переопределение, а абстрактный требует реализацию.

**Источник.** https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.3

К каким методам неприменимы принципы позднего связывания? Почему?

**Ответ.** К статическим методам и методам с модификаторами private и final. Вышеназванные методы по своей сути являются не переопределяемыми, а при их вызове используется информация о типе ссылочной переменной, а не конкретный объект.

**Источник.** И. Блинов. Java. Промышленное программирование. с. 88.

В чем заключается отличие между ранним и поздним связыванием?

**Ответ:**
1.	Статическое связывание происходит во время компиляции, а динамическое – во время выполнения.
2.	Поскольку статическое связывание происходит на ранней стадии жизненного цикла программы, его называют ранним связыванием. Аналогично, динамическое связывание называют также поздним связыванием, поскольку оно происходит позже, во время работы программы.
3.	Статическое связывание используется в языке Java для разрешения перегруженных методов, в то время как динамическое связывание используется в языке Java для разрешения переопределенных методов.
4.	Аналогично, приватные, статические и терминальные методы разрешаются при помощи статического связывания, поскольку их нельзя переопределять, а все виртуальные методы разрешаются при помощи динамического связывания.
5.	В случае статического связывания используются не конкретные объекты, а информация о типе, то есть для обнаружения нужного метода используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода в Java используется конкретный объект.
      
**Источник.** https://javarush.ru/groups/posts/439-razlichija-mezhdu-rannim-i-pozdnim-svjazihvaniem-v-java

Бонусное задание 1 (необязательное)
Добавить к задаче inheritance2 пункт:
8. Найти в отсортированном массиве ВСЕ покупки со стоимостью 5.00 BYN, для первоначального поиска использовав метод Arrays.binarySearch( ).
   Желательно найти такое решение, которое после поиска позволяет выполнить задачу за один цикл.
   Трюки типа Arrays.copyOfRange() не засчитываются, т.к. они реализованы через цикл.
   То есть если быть максимально точным, то должен быть один цикл, и вычислительная сложность алгоритма после вызова метода Arrays.binarySearch( ) должна быть равна O(n).
   Подсказка 1 - это решение существует )
   Подсказка 2
   ----------------- см. следующую строку -------------
   В чем смысл отрицательного значения метода binarySearch()?
---------------------------------------------------------------

